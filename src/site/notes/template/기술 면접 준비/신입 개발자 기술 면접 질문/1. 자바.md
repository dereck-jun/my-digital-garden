---
{"dg-publish":true,"permalink":"/template///1/"}
---

### 💡 Java의 특징을 설명해주세요

자바는 **객체 지향 프로그래밍 언어**입니다. 기본 자료형을 제외한 모든 요소들이 객체로 표현되고, **객체 지향 개념의 특징**인 상속, 추상화, 다형성, 캡슐화가 **잘 적용된 언어**입니다. 

장점으로는 JVM(자바 가상 머신) 위에서 동작하기 때문에 **운영체제에 독립적**이며, GC(가비지 컬렉션)를 통한 **자동적인 메모리 관리가 가능**한 것이고, 단점은 JVM 위에서 동작하기 때문에 **실행 속도가 상대적으로 느리며, 다중 상속이나 타입에 엄격하며 제약이 많다는 것**이 있습니다.


### 💡 JVM의 역할에 대해 설명해주세요

JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석해주는 역할을 하고, GC를 통해 자동적인 메모리 관리를 해줍니다.


### 💡 Java의 컴파일 과정에 대해 설명해주세요

1. 개발자가 `.java` 파일을 생성하면 
2. `build`를 합니다.
3. java compiler의 javac 명령어를 통해 바이트코드(`.class`)를 생성하고,
4. Class Loader를 통해 JVM 메모리 내로 로드합니다.
5. 실행 엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석됩니다.


### 💡 Java에서 제공하는 원시 타입에는 무엇이 있나요? 그리고 각각 몇 바이트를 차지하나요?

정수형에 byte, short, int, long 타입이 있고, 문자형에 char, 실수형에 float, double, 논리형에 boolean 타입이 있습니다. 그리고 순서대로 정수형 1, 2, 4, 8 바이트, 문자형 2 바이트, 실수형 4, 8 바이트, 논리형 1 바이트를 차지합니다.


### 💡 오버라이딩(overriding)과 오버로딩(overloading)에 대해 설명해주세요

오버라이딩은 **상위 클래스에 있는 메서드를 하위 클래스에서 재정의 하는 것**을 말하고, 오버로딩은 **매개변수의 개수나 타입을 다르게 하여 같은 이름의 메서드를 여러 개 정의하는 것**을 말합니다.


### 💡 객체지향 프로그래밍(OOP)에 대해 설명해주세요

우리가 실생활에서 쓰는 모든 것을 객체라 하고, 객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 상태와 행위를 가진 객체를 만들고 각각의 객체들의 역할이 무엇인지를 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말합니다. 

즉, 기능이 아닌 객체가 중심이며 "누가 어떤 일을 할 것인가?"가 핵심입니다. 특징으로는 상속, 추상화, 다형성, 캡슐화 등이 있고, 모듈 재사용으로 확장 및 유지보수가 용이합니다.


### 💡 try-with-resource에 대해 설명해주세요

`try-catch-finally`의 문제점을 보완하기 위해 나온 개념입니다. **try 구문 안에 자원 객체를 전달하면, try 블록이 끝나고 자동으로 자원을 해제** 해주는 기능을 말합니다. **따로** finally 구문이나 모든 catch 구문에 **종료 처리를 하지 않아도 된다는 장점**이 있습니다.

```java
try (BufferedReader br = new BufferedReader(new FileReader("test.txt"))) { 
	String line; 
	while ((line = br.readLine()) != null) { 
		System.out.println(line); 
	} 
} catch (IOException e) { 
	e.printStackTrace(); 
}
```

> Java 7에서 추가된 개념이고, try에 전달할 수 있는 자원은 AutoCloseable 인터페이스(JDK 1.7)의 구현체로 한정된다. 또한 try 안에 복수의 자원 객체를 전달할 수 있다. 


### 💡 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요

불변 객체(Immutable Object)는 **생성 이후 내부 상태가 변하지 않는 객체**를 의미합니다. 이는 **read-only 메서드만을 제공**하며, **내부 상태를 제공하는 메서드는 제공하지 않거나 방어적 복사를 통해 제공**합니다. 

Java의 **대표적인 불변 객체에는 String**이 있습니다. String은 Java의 대표적인 불변 클래스로, String Pool에 String 객체를 보관하고 있습니다. **변수에 새로운 값을 할당**할 경우, 객체의 값이 변하는 것이 아닌 **새로운 객체가 생성되어 해당 객체를 참조**하게 됩니다. 
****
> [!FAQ]- 참조 타입일 경우 추가적인 작업
> 추가적인 작업에는 **방어적 복사**와 **Unmodifiable Collection**이 있다.
> 
> 참조 타입의 필드를 포함하는 불변 객체를 생성할 때, 필드의 값을 반환하는 메서드는 외부에서 필드의 값을 변경할 수 없도록 하기 위해 **방어적 복사**를 통해 제공해야 한다.
> 
> 컬렉션 타입의 필드를 포함하는 불볍 객체를 생성할 때, 필드의 값을 반환하는 메서드는 외부에서 필드의 값을 변경할 수 없도록 하기 위해 **Unmodifiable Collection**을 통해 제공해야 한다.

> [!FAQ]- 불변 객체나 final을 굳이 사용해야 하는 이유
> 1. **Thread-Safe**하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 됨
> 	- 공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문
> 2. **실패 원자적인 메서드**를 만들 수 있음
> 	- 어떠한 예외가 발생되더라도 메서드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능
> 3. **부수효과를 피해 오류를 최소화** 할 수 있음
> 	- 변수의 값이 바뀌거나, 객체의 필드 값을 설정하거나, 예외나 오류가 발생하여 실행이 중단하는 오류 최소화
> 4. **메서드 호출 시 파라미터 값이 변하지 않는다는 것을 보장**할 수 있음
> 5. **GC의 성능**을 높일 수 있음
> 	- GC가 스캔하는 객체의 수가 줄기 때문에 지연 시간이 줄어들게 됨


### 💡 추상 클래스와 인터페이스를 설명하고, 그 차이를 말해주세요

추상 클래스는 **추상 메서드를 하나 이상 포함**하거나 **`abstract`로 정의된 클래스**입니다. **추상 메서드와 일반 메서드를 모두 포함**할 수 있으며, **인스턴스 변수를 가질 수 있**습니다. **`extends` 키워드를 통한 상속으로 기능을 확장하거나 일부 구현**을 할 수 있으며 **단일 상속**만을 허용합니다. 공통적인 기능을 일부 구현하고, 나머지는 상속받는 클래스에서 구현하도록 **강제하는데 사용**되어 코드의 재사용성을 높이고, 일관된 구현을 보장합니다.

인터페이스는 **모든 메서드가 기본적으로 추상 메서드**이며, **Java 8부터는 default 메서드와 static 메서드를 포함**할 수 있습니다. **상수만을 포함**할 수 있고, **`implements` 키워드**를 통한 **다중 구현**이 가능합니다. 느슨한 결합을 가능하게 하며, **구현 클래스가 인터페이스의 메서드를 반드시 구현**해야 하므로, **일관된 API를 제공**할 수 있습니다.

추상 클래스와 인터페이스는 공통적으로 인스턴스를 생성할 수 없으며, 하나 이상의 추상 메서드를 포함할 수 있다는 공통점이 있습니다.


### 💡 싱글톤 패턴(Singleton Pattern)에 대해 설명해주세요

싱글톤 패턴은 **단 하나의 인스턴스를 생성해 사용하는 디자인 패턴**입니다. **인스턴스가 1개만 존재해야 한다는 것을 보장**하고 싶은 경우와 **동일한 인스턴스를 자주 생성**해야 하는 경우에 **메모리 낭비 방지**를 위해 사용합니다.

> [!FAQ]- 싱글톤 패턴의 대표적인 예시
> 싱글톤 패턴의 대표적인 예시는 **Spring Bean**이 있음. 스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프이고, **스프링 컨테이너는 모든 빈들을 싱글톤으로 관리**함. 하지만 `@Scope("prototype")` 어노테이션을 이용하여 프로토타입으로 생성해서 반환하는 기능도 제공함.


### 💡 가비지 컬렉션(Garbage Collection)에 대해 설명해주세요

가비지 컬렉션은 자바의 메모리 관리 방법 중 하나로, **JVM이 Heap 영역에서 동적으로 할당했던 메모리 중 더 이상 사용할 수 없게 된 영역을 해제하는 기능**입니다. 이는 프로그래머가 **수동으로 메모리를 해제하지 않아**도 되며, **메모리 누수나 잘못된 메모리 참조와 같은 일부 버그를 방지**할 수 있습니다.

> [!FAQ]- 가비지 컬렉션 과정
> 1. **Mark(표시)**: GC는 루트 객체 집합(root set)에서부터 시작하여 접근 가능한 객체를 표시(mark)합니다. 이 단계에서는 객체가 참조되고 있는지 여부를 판단하여, **참조되지 않는 객체를 식별**합니다.
> 2. **Sweep(쓸기)**: 표시되지 않는 객체는 가비지로 간주하여 삭제(sweep)합니다. 이 단계에서는 메모리 회수를 위해 **사용되지 않는 객체를 식별**하고, 해당 객체의 **메모리를 해제**합니다.
> 3. **Compact(압축)**: 일부 GC 알고리즘에서는 **Sweep 후에 분산된 객체들을** Heap 영역의 시작 주소로 모아 **메모리가 할당된 부분과 그렇지 않은 부분으로 압축**합니다. 이는 **메모리 공간을 효율적으로 사용하기 위함**입니다.

> [!info]- 가비지 컬렉션의 구동 방식과 Generation
> 1. **Stop-The-World**: GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 시간입니다. 이 시간 동안 **GC를 실행하는 쓰레드를 제외한 나머지 모든 쓰레드들은 모두 일시적으로 멈추**게 됩니다.
> 2. **Heap 메모리 구조**: Heap은 Young Generation과 Old Generation으로 나뉘어집니다. **Young Generation은 짧게 살아남는 메모리**들이 존재하는 공간이고, **Old Generation은 오래 살아남는 메모리**들이 존재하는 공간입니다.
> 3. **Minor GC와 Major GC**: Young Generation에서 발생되는 GC를 Minor GC라고 하며, Old Generation에서 발생되는 GC를 Major GC라고 합니다.


### 💡 객체 지향의 설계 원칙에 대해 설명해주세요

객체 지향 설계 원칙에는 5가지 원칙이 있습니다. 

1. **SRP - 단일 책임 원칙**: 한 클래스는 하나의 책임만 가져야 한다. (캡슐화)
2. **OCP - 개방 폐쇄 원칙**: 확장에는 열려있지만 수정에는 닫혀있어야 한다. (추상화/다형성)
3. **LSP - 리스코프 치환 원칙**: 하위 타입은 항상 상위 타입을 대체할 수 있어야 한다.
	- 다형성과 확장성을 극대화하며, OCP 원칙을 구성한다.
4. **ISP - 인터페이스 분리 원칙**: 인터페이스 내에 메서드는 최소한 일수록 좋다.
	- 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.
	- SRP와 ISP는 같은 문제에 대한 두 가지 다른 해결책이다. (SRP 권장)
5. **DIP - 의존관계 역전 원칙**: 구체적인 클래스보다 상위 클래스, 인터페이스 추상 클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라.
	- DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다.
	- 구현 객체(저수준 모듈)가 아닌 인터페이스(고수준 모듈) 등을 의존하라는 의미.


### 💡 자바의 메모리 영역에 대해 설명해주세요

자바의 메모리 공간은 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당됩니다.

- **Method 영역**: Class의 정보, static 변수(클래스 변수), 생성자, 메서드와 같은 것들을 저한다. static 영역에 있는 것은 어디서든 접근 가능하며, 프로그램이 종료되기 전까진 메리 상에 존재한다. 무분별하게 사용 시 메모리 부족 현상이 발생할 수 있다.
- **Stack 영역**: 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메서드가 호출될 때 메리에 할당되고, 종료되면 메모리가 해제된다. LIFO 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.
- **Heap 영역**: 참조형 데이터 객체(`String`, `Array`, `Enum`, `List`, `Object` ...)의 실체 데이터가 저장되는 공간이다. Stack 영역에서 실제 데이터가 존재하는 Heap 영역의 참조값을 가지고 있다.[^2] `new` 키워드로 인스턴스를 생성할 때, Heap 영역에는 생성된 객체가 저장되고, Stack 영역에서 생성된 객체에 대한 주소값(Reference)이 저장된다. 

> [!FAQ]- 각 메모리 영역이 할당되는 시점
> - **Method 영역**: JVM이 동작해서 클래스가 로딩될 때 생성
> - **Stack 영역**: 각 쓰레드가 시작될 때 생성되며, 메서드가 호출될 때마다 할당
> - **Heap 영역**: JVM이 시작될 때 생성되며, 객체가 생성될 때마다 할당


### 💡 클래스와 객체에 대해 설명해주세요

클래스는 **객체를 만들어내기 위한 설계도 혹은 틀** 이라고 할 수 있고, **객체를 생성하는데 사용**합니다. 객체는 클래스를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다. 여기서 **상태는 필드**, **행동은 메서드**라고 표현합니다. 클래스의 타입으로 선언되었을 때 '객체'라고 부르고, 객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다.[^1]


### 💡 생성자(Constructor)에 대해 설명해주세요

생성자는 **클래스와 같은 이름의 메서드로, 객체가 생성될 때 호출되는 메서드**입니다. 명시적으로 생성자를 **만들지 않아도 default**로 만들어지며, 생성자는 **파라미터를 다르게하여 오버로딩**할 수 있습니다.


### 💡 Wrapper Class 란 무엇이며, Boxing과 UnBoxing은 무엇인지 설명해주세요

**기본 자료형에 대한 객체 표현을 Wrapper Class**라고 합니다. **기본 자료형에서 Wrapper Class로 변환**하는 것을 **Boxing**이라고 하며, **Wrapper Class에서 기본 자료형으로 변환**하는 것을 **UnBoxing**이라 합니다.


### 💡 Synchronized 에 대해 아는 대로 설명해주세요

Synchronized는 **자바에서 멀티 스레드 환경에서 공유 자원에 대한 접근을 제어하는 키워드**입니다. Synchronized를 사용하면, 여러 쓰레드가 동시에 공유 자원에 접근하지 못하도록 하여, **데이터의 일관성을 유지**할 수 있지만 Lock을 획득하고 해제하는 과정에서 **성능의 저하**가 발생할 수 있고, 두 개 이상의 쓰레드가 서로의 Lock을 기다리는 상태인 **데드락이 발생**할 수 있습니다.

> [!info]- Synchronized 작동 방식
> 1. **Lock 획득**: Synchronized 블록 또는 메서드를 실행하는 쓰레드는 Lock을 획득합니다.
> 2. **Lock 보유**: Lock을 획득한 쓰레드는 해당 블록 또는 메서드를 실행합니다.
> 3. **Lock 해제**: Lock을 보유한 쓰레드는 해당 블록 또는 메서드를 종료하면 Lock을 해제합니다.
> 4. **Lock 대기**: 다른 쓰레드는 Lock이 해제될 때까지 대기합니다.


### 💡 new String() 과 리터럴("") 의 차이에 대해 설명해주세요

**리터럴을 사용**하여 String 객체를 생성할 때는 **string constant pool에 값이 저장**됩니다. 이는 **동일한 문자열을 여러 번 생성해도, 동일한 객체를 참조**합니다. == 연산자로 객체 비교 시 동일한 객체를 참조하기 때문에 `true`가 반환되고, **기존 객체의 참조를 반환하므로 성능이 향상**됩니다.

**new 연산자**로 String 객체를 생성하면 **Heap 메모리에 새로운 객체를 생성**합니다. 이는 **동일한 문자열을 여러 번 생성하면 각각 새로운 객체가 생성**됩니다. == 연산자로 객체 비교 시 
각각 다른 객체이기 때문에 `false`를 반환하고, **새로운 객체를 생성하는 데 시간이 걸리므로, 성능이 저하**될 수 있습니다.


### 💡 String, StringBuffer, StringBuilder 의 차이를 설명해주세요

**String 클래스는 불변성**을 가지며, 생성된 후에는 내용을 변경할 수 없습니다. 또한 문자열 **리터럴을 사용하여 생성**할 수 있으며, JVM은 문자열 리터럴을 `String constant pool`에서 관리합니다. 

**StringBuffer 클래스와 StringBuilder 클래스는 가변성**을 가지며, 생성된 후에도 내용을 변경할 수 있습니다. 

**StringBuffer는 동기화(synchronization)** 기능을 제공하여 멀티 쓰레드 환경에서도 안전하게 사용할 수 있고, **StringBuilder는 비동기화(asynchronization)** 기능을 제공하여 멀티 쓰레드 환경에서 사용할 때 주의가 필요합니다.

> [!faq]- String 객체가 불변인 이유
> 1. **성능**: 문자열 리터럴을 캐싱하고 재사용하면 문자열 풀의 다른 문자열 변수가 동일한 객체를 참조하기 때문에 Heap 메모리 공간을 절약할 수 있다.
> 2. **보안**: String은 클래스 로더에서 사용되는데, 만약 String이 가변이라면, 클래스 로더가 올바른 클래스를 로드하지 못할 수 있다. 또한 보안 검증 로직 실행 이후에도 해당 문자열이 안전하다고 보장할 수 없게 된다.
> 3. **동기화와 동시성**: String은 여러 쓰레드에서 공유될 수 있기 때문에 가변일 경우, 여러 쓰레드가 동시에 String을 수정할 수 있어, 데이터 일관성이 깨질 수 있다.
> 4. **HashCode 캐싱**: HashCode는 아직 hash 값을 계산한 적이 없을 때 최초 1번만 실제 계산 로직을 수행하고, 이후 해당 값을 그냥 리턴하도록 재정의 되어 있다. 따라서 해시 구현을 사용하는 컬렉션의 성능 상 이점을 얻는다. 


### 💡 접근 제한자(Access Modifier)에 대해 설명해주세요

접근 제한자는 **클래스, 메서드, 필드 등의 접근을 제한하는 키워드**입니다. 클래스에는 `public`과 `default` 접근 제한자만 사용할 수 있으며, 메서드와 필드는 `public`, `protected`, `default`, `private` 접근 제한자를 사용할 수 있습니다. 접근 제한자를 사용하여, 클래스의 내부 구현을 외부에서 접근하지 못하도록 하여, **캡슐화를 구현**할 수 있습니다. 

> [!info]- 접근 제한자의 종류
> - **public**: 모든 클래스에서 접근할 수 있습니다.
> - **protected**: 같은 패키지 내의 클래스와 상속 받은 클래스에서 접근할 수 있습니다.
> - **default**: 같은 패키지 내의 클래스에서 접근할 수 있습니다.
> - **private**: 같은 클래스 내에서만 접근할 수 있습니다.


### 💡 클래스 멤버 변수 초기화 순서에 대해 설명해주세요

클래스 멤버 변수의 초기화 순서는 먼저 **클래스 변수**가 **기본값**, **명시적 초기화**, **클래스 초기화 블럭**의 순서로 **초기화 된 후**, **인스턴스 변수**가 **기본값**, **명시적 초기화**, **인스턴스 초기화 블럭**, **생성자**의 순서로 초기화 됩니다. 이때 **클래스 변수와 클래스 초기화 블럭은 클래스가 처음 로딩될 때 단 한번 초기화**되고, **인스턴스 변수와 인스턴스 초기화 블럭은 인스턴스가 생성될 때마다 초기화**됩니다. 

```java
class InitTest { 
	static int classVariable = 1; // 명시적 초기화 
	int instanceVariable = 1; 
	
	static { // 클래스 초기화 블럭
		classVariable = 2; 
	}  
	
	{ // 인스턴스 초기화 블럭
		instanceVariable = 2; 
	}  
	
	InitTest() { // 생성자 
		instanceVariable = 3; 
	} 
}
```


### 💡 static에 대해 설명해주세요

static은 자바에서 사용되는 키워드로, **클래스의 멤버 변수나 메서드를 클래스 자체에 속하게 하는 키워드**입니다. static 키워드를 사용하면, **클래스의 모든 인스턴스에서 공유**되는 단 하나의 멤버 변수나 메서드를 생성할 수 있습니다. 또한 **프로그램이 시작될 때 메모리에 할당**되고, **프로그램이 종료될 때 해제**되며, **객체를 생성하지 않고도 사용**할 수 있습니다.

이러한 static은 **메모리 문제**, **동시성 문제**를 유발할 수 있으며 static 메서드는 프록시 객체가 원본 객체를 상속할 때 재정의 하지 않기 때문에 **테스트하기 어려울** 수 있으므로 사용할 때 주의해야 합니다.

> [!faq]- static을 사용하는 이유 
> 1. **메모리 효율**: static 멤버는 클래스의 모든 인스턴스에서 공유되므로, 메모리 사용을 최적화할 수 있다
> 2. **편리한 사용**: static 멤버는 객체를 생성하지 않고도 사용할 수 있다
> 3. **상수 선언**: static 키워드로 상수를 선언할 수 있다
> 4. **유틸리티 메서드**: static 키워드로 유틸리티 메서드를 선언할 수 있다.

### 💡 Inner Class의 장점에 대해 설명해주세요

내부 클래스는 다음과 같은 장점이 있습니다.

1. **클래스를 논리적으로 그룹화**
	- 클래스가 하나의 특정 클래스와만 관계를 맺는다면, 외부에 클래스를 새로 작성하는 것이 아닌 내부 클래스로 작성할 수 있다.
	- 내부 클래스와 외부 클래스를 함께 관리하는 것이 가능해 **유지보수나 코드 이해성 측면에서 편리**해진다.
	- 새로운 클래스를 생성하지 않아도 되므로 **패키지를 간소화**할 수 있다.
2. **더욱 타이트한 캡슐화의 적용**
	- 내부 클래스에 private 제어자를 적용함으로써, 캡슐화를 통해 클래스를 내부로 숨길 수 있다.
	- 캡슐화를 통해 외부에서의 접근을 차단하면서 **내부 클래스에서 외부 클래스의 멤버들을 제약 없이 쉽게 접근**할 수 있어 구조적인 프로그래밍이 가능해진다.
	- 클래스 구조를 숨김으로써 코드의 복잡성을 줄일 수 있다.
3. **가독성이 좋고 유지 관리가 쉬운 코드**
	- 어차피 특정 클래스 안에서만 사용하기 위한 클래스이니 내부에 선언해 **직관적으로 사용**하자는 취지

> [!info]- 내부 클래스의 종류
> - **인스턴스 클래스**: 외부 클래스의 멤버 변수 선언 위치에 선언하며, 외부 클래스의 인스턴스 멤버처럼 다뤄진다. 주로 외부 클래스의 인스턴스 멤버들과 관련된 작업에 사용될 목적으로 선언된다.
> - **정적 클래스**: 외부 클래스의 멤버 변수 선언 위치에 선언하며, 외부 클래스의 static 멤버처럼 다뤄진다. 다만 주의할 점은 static이라고 해서 new 생성자 초기화를 못하는 건 아니다. 즉, 일반적인 static 멤버와는 다르게 static 내부 클래스는 메모리 구조나 기능이 전혀 다르다.
> - **로컬 클래스**: 외부 클래스의 메서드나 초기화 블럭 안에 선언하며, 선언된 메서드 블록 영역 내부에서만 사용될 수 있다.
> - **익명 클래스**: 클래스의 선언과 객체의 생성을 동시에 하는 익명 클래스이다. 주로 클래스를 일회용으로 사용할 때 주로 사용한다.


### 💡 Reflection에 대해 설명해주세요

Reflection은 **구체적인 클래스 타입을 알지 못하더라도** 그 클래스의 메서드, 타입, 변수들에 **접근할 수 있도록 해주는 자바 API**를 말하며, 컴파일 시간이 아닌 **실행 시간에 동적으로 특정 클래스의 정보를 추출**할 수 있는 프로그래밍 기법이라 할 수 있습니다.

Reflection을 사용하여 가져올 수 있는 정보에는 Class, Constructor, Method, Field가 있습니다.

> [!faq]- Reflection이 사용되는 경우
> Reflection은 작성 시점에는 어떤 클래스를 사용해야 할지 몰라서 런타임 시점에서 가져와 실행해야 하는 경우 사용합니다.

### 💡 Error와 Exception의 차이를 설명해주세요

Error(오류)는 자바에서 발생하는 **치명적인 오류**를 나타내는 클래스입니다. **시스템이 종료되어야 할 수준**의 상황과 같이 **수습할 수 없는 심각한 문제**를 의미합니다. 개발자가 미리 예측하여 방지할 수 없습니다.

Exception(예외)은 자바에서 발생하는 **예외적인 상황**을 나타내는 클래스입니다. **개발자가 구현한 로직에서 발생한 실수로 인한 프로그램의 논리적 오류 또는 외부 요인**에 의해 발생하며, 개발자가 미리 예측하여 방지할 수 있기에 상황에 맞는 **예외 처리**를 해야합니다.

### 💡 CheckedException과 UnCheckedException의 차이를 설명해주세요

CheckedException은 **컴파일 예외**라고도 하며 **Exception을 바로 상속**받습니다. **컴파일 시점에 예외 처리를 하지 않는다면 컴파일 에러가 발생**하며, 트랜잭션 rollback이 안된다는 속성도 있습니다. 예외가 발생하는 메서드에서 `throws` 예약어를 활용하여 예외를 호출한 메서드에 전달하는 방법으로도 처리가 가능합니다.

UnCheckedException은 **RuntimeException을 상속**받습니다. 트랜잭션 rollback이 가능하며, 컴파일 시점에 예외가 발생하는가에 대한 여부를 판단할 수 없습니다. 컴파일 시점에 예외 처리를 하는지 확인하지 않기에 메서드에서 `throws` 예약어를 통한 예외 처리를 할 필요가 없습니다. 즉, 명시적으로 예외 처리를 강제하지 않습니다.

### 💡 Optional API에 대해 설명해주세요

Optional이란 **null이 올 수 있는 값을 감싸는 Wrapper 클래스**로, 참조하더라도 **NPE(NullPointerException)가 발생하지 않도록** 도와줍니다. Optional은 값을 Wrapping하고 다시 풀고, null일 경우엔 대체하는 함수를 호출하는 등의 **오버헤드**가 있으므로 잘못 사용하면 **성능이 저하**됩니다. 따라서 Optional은 **메서드의 결과가 null이 될 수 있으며, null에 의해 오류가 발생할 가능성이 매우 높을 때 반환 값으로만 사용**되어야 합니다. 또한 파라미터로 넘어가는 등이 아닌 **반환 타입으로써 제한적으로 사용**되도록 설계되었습니다.

### 💡 컬렉션 프레임워크에 대해 설명해주세요

컬렉션 프레임워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 **표준화된 방법을 제공하는 클래스의 집합**을 의미합니다. 즉, **데이터를 저장하는 자료 구조와 데이터를 처리하는 알고리즘을 구조화하여 클래스로 구현해 놓은 것**입니다. 이러한 컬렉션 프레임워크는 자바의 **인터페이스**를 사용하여 구현됩니다.

컬렉션 프레임워크의 장점은 다음과 같습니다.

- 인터페이스의 다형성을 이용한 객체 지향적 설계를 통해 표준화되어 있기 때문에, 사용법을 익히기에도 **편리하고 재사용성이 높다**.
- 데이터 구조 및 알고리즘의 고성능 구현을 제공하여 **프로그램의 성능과 품질을 향상**시킨다.
- 관련 없는 API 간의 상호 운용성을 제공한다. (상위 **인터페이스 타입으로 업캐스팅**하여 사용)
- 이미 구현되어있는 API를 사용하면 되기에, 새로운 API를 **익히고 설계하는 시간**이 줄어든다.
- **소프트웨어 재사용을 촉진**한다. 만일 자바에서 지원하지 않는 새로운 자료 구조가 필요하면, 컬렉션들을 재활용하여 조합 후 새로운 알고리즘을 만들어낼 수 있다.

> [!faq]- List, Stack, Queue, Set, Map의 특징
> 1. List
> 	- 저장 **순서가 유지**되는 컬렉션을 구현하는 데 사용
> 	- **같은 요소의 중복 저장을 허용**
> 	- **index로 요소에 접근**
> 	- 자료형의 **크기를 동적**으로 설정할 수 있음
> 	- 빈 공간을 허용하지 않음 -> **삽입/삭제 마다 배열 이동**이 일어남
> 2. Stack
> 	- **후입선출**(LIFO: Last-In-First-Out) 자료 구조
> 	- 들어올 때 **push**, 나갈 때 **pop** 사용
> 	- Stack은 Vector를 상속하기 때문에 문제점이 많아 잘 안쓰임 -> ArrayDeque 사용
> 3. Queue
> 	- **선입선출**(FIFO: First-In-First-Out) 자료 구조
> 	- 자바에서는 필요에 따라 Queue 컬렉션을 골라 사용할 수 있음
> 		- PriorityQueue 또는 ArrayDeque
> 4. Set
> 	- 데이터의 **중복을 허용하지 않고 순서가 없는** 데이터의 집합 리스트
> 	- 순서 자체가 없으므로 index로 객체를 검색하는 `get(index)` **메서드도 존재하지 않음**
> 	- 중복 저장이 불가능하기 때문에 **null 값도 하나만 저장**할 수 있음
> 5. Map
> 	- **키(Key)와 값(Value)의 쌍**으로 연관지어 이뤄진 데이터의 집합
> 	- **값은 중복 저장이 가능**하지만, **키는 해당 Map에서 고유**해야 함
> 	- 기존에 저장된 데이터와 중복된 키로 저장하면 **기존의 값은 없어지고 마지막에 저장된 값이 남게 됨**
> 	- 저장 **순서가 유지되지 않음**

### 💡 Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명해주세요.

hashCode() 메서드를 재정의하여 반환된 해시코드 값이 다르다면 다른 객체로 판단하고, 같다면 equals() 메서드를 재정의하여 다시 비교합니다. 이 두 개가 모두 맞다면 중복 객체로 판단합니다.

### 💡 Vector와 List의 차이를 설명해주세요

Vector는 **데이터 삽입 시 원소를 밀어**내고, **랜덤 부분 접근이 가능**하며, **항상 동기화** 됩니다. 따라서 **검색적인 측면에서 시간복잡도의 우위**를 가지고, **멀티 쓰레드 환경에서 안전**하지만 단일 쓰레드 환경에서도 동기화를 하기 때문에 **List보다 성능이 떨어**집니다.

List는 **노드가 양쪽으로 연결**되어 있으며, **동기화되지 않**습니다. 따라서 **삽입 및 삭제의 측면에서 시간복잡도의 우위**를 가지고, **멀티 쓰레드 환경에서 안전하지 않**지만 **Vector보다 성능이 좋**습니다.

### 💡 제네릭이 무엇인지, 왜 사용하는지 설명해주세요

제네릭이란 클래스 내부에서 사용할 **데이터 타입을 외부에서 지정**하는 기법을 의미합니다. **객체 별로 다른 타입의 자료가 저장**될 수 있도록 합니다. **다이아몬드 연산자 사이에 타입을 지정**하여 해당 타입의 데이터만 저장할 수 있게 됩니다. 이처럼 제네릭은 내부 데이터 타입을 파라미터 주듯이 외부에서 지정하는 이른바 **타입을 변수화 한 기능**이라고 볼 수 있습니다.

제네릭을 사용하는 이유는 클래스나 메서드를 정의할 때 타입 파라미터로 객체의 서브 타입을 지정해 주기 때문에 **컴파일 타임에 타입 검사를 통해 예외를 방지**할 수 있으며, 미리 타입을 지정 및 제한해 놓기 때문에 **불필요한 캐스팅을 없애 성능을 향상**시킬 수 있기 때문입니다.

### 💡 final, finally, finalize의 차이를 설명해주세요

**final은** 클래스, 메서드 또는 변수에서 사용되어 **변경이 불가능함**을 나타내며, **finally는** **try-catch** 블록과 함께 사용되어 **예외 발생과 상관없이 항상 실행되는 코드를 정의**하고, **finalize는** 객체가 소멸되기 직전에 호출되어 **객체의 정리 작업을 수행**합니다.

### 💡 직렬화(Serialize)에 대해 설명해주세요

직렬화란 메모리를 디스크에 저장하거나, 네트워크 통신에 사용하기 위한 형식으로 변환하는 것입니다. 자바 직렬화는 자바 시스템 내부에서 사용되는 객체 또는 데이터를 외부의 자바 시스템에서도 사용할 수 있도록 바이트 스트림(stream of bytes) 형태의 연속적인(serial) 데이터로 변환하는 포멧 변환 기술을 말합니다. 

JVM의 Heap 또는 Stack 메모리에 상주하고 있는 객체 데이터를 직렬화를 통해 바이트 형태로 변환하여 데이터베이스나 파일과 같은 외부 저장소에 저장해두는 것으로 볼 수 있습니다.

> [!faq]- 역직렬화란?
> 직렬화의 반대 개념인 역직렬화(Deserialize)는 디스크에 저장한 데이터를 읽거나, 네트워크 통신으로 받은 데이터를 메모리에 쓸 수 있도록 변환하는 것이다. 자바 역직렬화는 바이트로 변환된 데이터를 다시 객체로 변환하는 기술을 뜻한다.

> [!faq]- 바이트 스트림이란?
> 스트림은 클라이언트나 서버 간에 출발지 목적지로 입출력하기 위한 **데이터가 흐르는(=데이터를 운반하는데 사용되는) 통로**를 말한다. 자바는 스트림의 기본 단위를 바이트로 두고 있기 때문에, 네트워크, 데이터베이스로 전송하기 위해 최소 단위인 바이트 스트림으로 변환하여 처리한다.

### 💡 SerialVersionUID를 선언해야 하는 이유를 설명해주세요

SerialVersionUID(이하 SUID)를 선언하지 않으면, 내부적으로 클래스의 구조 정보를 이용하여 자동으로 생성된 해시 값이 할당되게 되는데, 이 때문에 클래스의 멤버 변수가 추가되거나 삭제되면 SUID가 달라져서 예외가 발생하기 때문입니다.

> [!info]- SUID에 대한 더 자세한 정보
> Serializable 인터페이스를 구현하는 모든 직렬화된 클래스는 SUID라는 고유 식별번호를 부여 받게된다. 이 식별 ID는 클래스를 직렬화, 역직렬화하는 과정에서 동일한 특성을 갖는지 확인하는데 사용된다. 클래스 내부 구성이 수정될 경우, 기존에 직렬화한 SUID와 현재 클래스의 SUID 버전이 다르기 때문에 이를 인지하고 `InvalidClassException` 예외를 발생시켜 값이 불일치 되는 현상을 미연에 방지한다.


[^1]: 두 개념을 크게 나눠서 생각하진 않는다.
[^2]: 참조형은 실제 인스턴스는 Heap 영역에 생성돼있고, 그 영역의 주소를 Stack 영역에서 저장하고 있다.