---
{"dg-publish":true,"permalink":"/template///1/"}
---

### 💡 Java의 특징을 설명해주세요

자바는 객체 지향 프로그래밍 언어입니다. 기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체 지향 개념의 특징인 상속, 추상화, 다형성, 캡슐화가 잘 적용된 언어입니다. 

장점으로는 JVM(자바 가상 머신) 위에서 동작하기 때문에 운영체제에 독립적이며, GC(가비지 컬렉션)를 통한 자동적인 메모리 관리가 가능한 것이고, 단점은 JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리며, 다중 상속이나 타입에 엄격하며 제약이 많다는 것이 있습니다.


### 💡 JVM의 역할에 대해 설명해주세요

JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석해주는 역할을 하고, GC를 통해 자동적인 메모리 관리를 해줍니다.


### 💡 Java의 컴파일 과정에 대해 설명해주세요

1. 개발자가 `.java` 파일을 생성하면 
2. `build`를 합니다.
3. java compiler의 javac 명령어를 통해 바이트코드(`.class`)를 생성하고,
4. Class Loader를 통해 JVM 메모리 내로 로드합니다.
5. 실행 엔진을 통해 컴퓨터가 읽을 수 있는 기계어로 해석됩니다.


### 💡 Java에서 제공하는 원시 타입에는 무엇이 있나요? 그리고 각각 몇 바이트를 차지하나요?

정수형에 byte, short, int, long 타입이 있고, 문자형에 char, 실수형에 float, double, 논리형에 boolean 타입이 있습니다. 그리고 순서대로 정수형 1, 2, 4, 8 바이트, 문자형 2 바이트, 실수형 4, 8 바이트, 논리형 1 바이트를 차지합니다.


### 💡 오버라이딩(overriding)과 오버로딩(overloading)에 대해 설명해주세요

오버라이딩은 상위 클래스에 있는 메서드를 하위 클래스에서 재정의 하는 것을 말하고, 오버로딩은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메서드를 여러 개 정의하는 것을 말합니다.


### 💡 객체지향 프로그래밍(OOP)에 대해 설명해주세요

우리가 실생활에서 쓰는 모든 것을 객체라 하고, 객체 지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 상태와 행위를 가진 객체를 만들고 각각의 객체들의 역할이 무엇인지를 정의하여 객체들 간의 상호작용을 통해 프로그램을 만드는 것을 말합니다. 

즉, 기능이 아닌 객체가 중심이며 "누가 어떤 일을 할 것인가?"가 핵심입니다. 특징으로는 상속, 추상화, 다형성, 캡슐화 등이 있고, 모듈 재사용으로 확장 및 유지보수가 용이합니다.


### 💡 try-with-resource에 대해 설명해주세요

`try-catch-finally`의 문제점을 보완하기 위해 나온 개념입니다. try 구문 안에 자원 객체를 전달하면, try 블록이 끝나고 자동으로 자원을 해제 해주는 기능을 말합니다. 따로 finally 구문이나 모든 catch 구문에 종료 처리를 하지 않아도 된다는 장점이 있습니다.

> Java 7에서 추가된 개념이고, try에 전달할 수 있는 자원은 AutoCloseable 인터페이스(JDK 1.7)의 구현체로 한정된다. 또한 try 안에 복수의 자원 객체를 전달할 수 있다. 


### 💡 불변 객체가 무엇인지 설명하고 대표적인 Java의 예시를 설명해주세요

불변 객체는 객체 생성 이후 내부의 상태가 변하지 않는 객체를 말합니다. 자바에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있고, 참조 타입일 경우엔 추가적인 작업이 필요합니다.

> [!FAQ]- 참조 타입일 경우 추가적인 작업은 어떤게 있는지 설명해주세요
> 참조 타입은 대표적으로 객체를 참조하거나, 배열이나 List 등을 참조할 수 있습니다.
> 
> 참조 변수가 일반 객체인 경우 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 합니다.
> 
> 배열일 경우 배열을 받아 copy해서 저장하고, getter를 clone으로 반환하도록 하면 됩니다. 배열을 그대로 참조하거나, 반환할 경우 외부에서 내부 값을 변경할 수 있기 때문에 clone을 반환하여 외부에서 값을 변경하지 못하게 합니다.
> 
> List인 경우에도 배열과 마찬가지로 생성 시 새로운 List를 만들어 값을 복사하도록 해야 합니다. 이때 배열과 리스트는 내부를 복사하여 전달하는데, 이를 방어적 복사(defensive-copy)라고 합니다.

> [!FAQ]- 불변 객체나 final을 굳이 사용해야 하는 이유가 있을까요?
> 불변 객체나 final 키워드를 사용해 얻는 이점은 다음과 같습니다.
> 1. Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
> 	- 공유 자원이 불변이기 때문에 항상 동일한 값을 반환하기 때문
> 2. 실패 원자적인 메서드를 만들 수 있다.
> 	- 어떠한 예외가 발생되더라도 메서드 호출 전의 상태를 유지할 수 있어 예외 발생 전과 똑같은 상태로 다음 로직 처리 가능
> 3. 부수효과를 피해 오류를 최소화 할 수 있다.
> 	- 변수의 값이 바뀌거나, 객체의 필드 값을 설정하거나, 예외나 오류가 발생하여 실행이 중단하는 오류 최소화
> 4. 메서드 호출 시 파라미터 값이 변하지 않는다는 것을 보장할 수 있다.
> 5. GC의 성능을 높일 수 있다.
> 	- GC가 스캔하는 객체의 수가 줄기 때문에 지연 시간이 줄어들게 됨


### 💡 추상 클래스와 인터페이스를 설명하고, 그 차이를 말해주세요

추상 클래스는 클래스 내 추상 메서드가 하나 이상 포함되거나 `abstract` 키워드가 선언된 경우를 말하고, 인터페이스는 모든 메서드가 추상 메서드로만 이루어져 있는 것을 말합니다. 

공통점으로는 객체 생성이 불가능하며, 사용하기 위해선 하위 클래스에서 확장 또는 구현을 해야합니다. 

차이점으로는 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정 메서드(추상 메서드)가 반드시 구현된 상태여야 함을 강제하지만, 추상 클래스는 상속 받는 클래스들의 공통적인 로직을 추상화 시키고, 기능 확장을 위해 사용합니다. 또한 추상 클래스는 다중 상속이 불가능하지만, 인터페이스는 다중 구현이 가능합니다.


### 💡 싱글톤 패턴(Singleton Pattern)에 대해 설명해주세요

싱글톤 패턴은 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴입니다. 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와 동일한 인스턴스를 자주 생성해야 하는 경우에 메모리 낭비 방지를 위해 사용합니다.

> [!FAQ]- 싱글톤 패턴의 대표적인 예시를 간단하게 설명해주세요
> 싱글톤 패턴의 대표적인 예시는 Spring Bean 입니다. 스프링의 빈 등록 방식은 기본적으로 싱글톤 스코프이고, 스프링 컨테이너는 모든 빈들을 싱글톤으로 관리합니다. 하지만 `@Scope("prototype")` 어노테이션을 이용하여 프로토타입으로 생성해서 반환하는 기능도 제공합니다.


### 💡 가비지 컬렉션(Garbage Collection)에 대해 설명해주세요

가비지 컬렉션은 JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요 없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법입니다.

> [!FAQ]- 가비지 컬렉션 과정에 대해 설명해주세요
> GC의 작업을 수행하기 위해 JVM이 어플리케이션의 실행을 잠시 멈추고, GC를 실행하는 쓰레드를 제외한 모든 쓰레드의 작업을 중단 후 (Stop The World 과정) 사용하지 않는 메모리를 제거(Mark and Sweep 과정)하고 작업이 재개됩니다. GC의 작업은 Young 영역에 대한 Minor GC와 Old 영역에 대한 Major GC로 구분됩니다.


### 💡 객체 지향의 설계 원칙에 대해 설명해주세요

객체 지향 설계 원칙에는 5가지 원칙이 있습니다. 

1. SRP - 단일 책임 원칙: 한 클래스는 하나의 책임만 가져야 한다. (캡슐화)
2. OCP - 개방 폐쇄 원칙: 확장에는 열려있지만 수정에는 닫혀있어야 한다. (추상화/다형성)
3. LSP - 리스코프 치환 원칙: 하위 타입은 항상 상위 타입을 대체할 수 있어야 한다.
	- 다형성과 확장성을 극대화하며, OCP 원칙을 구성한다.
4. ISP - 인터페이스 분리 원칙: 인터페이스 내에 메서드는 최소한 일수록 좋다.
	- 하나의 일반적인 인터페이스보다 여러 개의 구체적인 인터페이스가 낫다.
	- SRP와 ISP는 같은 문제에 대한 두 가지 다른 해결책이다. (SRP 권장)
5. DIP - 의존관계 역전 원칙: 구체적인 클래스보다 상위 클래스, 인터페이스 추상 클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라.
	- DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다.
	- 구현 객체(저수준 모듈)가 아닌 인터페이스(고수준 모듈) 등을 의존하라는 의미.


### 💡 자바의 메모리 영역에 대해 설명해주세요

자바의 메모리 공간은 크게 Method 영역, Stack 영역, Heap 영역으로 구분되고, 데이터 타입에 따라 할당됩니다.

- Method 영역: 전역변수와 static 변수를 저장하며, Method 영역은 프로그램의 시작부터 종료까지 메모리에 남아있다.
- Stack 영역: 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메서드가 호출될 때 메리에 할당되고, 종료되면 메모리가 해제된다. LIFO 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워진다.
- Heap 영역: new 키워드로 생성되는 객체, 배열 등이 Heap 영역에 저장되며, GC에 의해 메리가 관리되어 진다.

#### 💡 각 메모리 영역이 할당되는 시점은 언제인가요?
- Method 영역: JVM이 동작해서 클래스가 로딩될 때 생성
- Stack 영역: 메서드가 호출될 때 할당
- Heap 영역: 런타임시 할당


### 💡 클래스와 객체에 대해 설명해주세요

클래스는 객체를 만들어내기 위한 설계도 혹은 틀 이라고 할 수 있고, 객체를 생성하는데 사용합니다. 객체는 클래스를 기반으로 생성되며, 자신의 고유 이름과 상태, 행동을 갖습니다. 여기서 상태는 필드, 행동은 메서드라고 표현합니다. 클래스의 타입으로 선언되었을 때 객체라고 부르고, 객체에 메모리가 할당되어 실제로 활용되는 실체는 '인스턴스'라고 부릅니다.

### 💡 생성자(Constructor)에 대해 설명해주세요

생성자는 클래스와 같은 이름의 메서드로, 객체가 생성될 때 호출되는 메서드입니다. 명시적으로 생성자를 만들지 않아도 default로 만들어지며, 생성자는 파라미터를 다르게하여 오버로딩할 수 있습니다.

### 💡 Wrapper Class 란 무엇이며, Boxing과 UnBoxing은 무엇인지 설명해주세요

기본 자료형에 대한 객체 표현을 Wrapper Class라고 합니다. 기본 자료형에서 Wrapper Class로 변환하는 것을 Boxing이라고 하며, Wrapper Class에서 기본 자료형으로 변환하는 것을 UnBoxing이라 합니다.

### 💡 Synchronized 에 대해 아는 대로 설명해주세요

### 💡 new String() 과 리터럴("") 의 차이에 대해 설명해주세요

### 💡 String, StringBuffer, StringBuilder 의 차이를 설명해주세요
#### 💡 String 객체가 불변인 이유에 대해 설명해주세요

### 💡 접근 제한자(Access Modifier)에 대해 설명해주세요

### 💡 클래스 멤버 변수 초기화 순서에 대해 설명해주세요

### 💡 static 에 대해 설명해주세요
#### 💡 static 을 사용하는 이유에 대해 설명해주세요

### 💡 Inner Class 의 장점에 대해 설명해주세요

### 💡 Reflection 에 대해 설명해주세요
#### 💡 Reflection 은 어떤 경우에 사용되는지 설명해주세요

### 💡 Error 와 Exception 의 차이를 설명해주세요

### 💡 CheckedException 과 UnCheckedException 의 차이를 설명해주세요

### 💡 Optional API 에 대해 설명해주세요

### 💡 컬렉션 프레임워크에 대해 설명해주세요
#### 💡 List, Set, Map, Stack, Queue의 특징에 대해 설명해주세요

### 💡 Set과 Map의 타입이 Wrapper Class가 아닌 Object를 받을 때 중복 검사는 어떻게 할건지 설명해주세요.

### 💡 Vector와 List의 차이를 설명해주세요

###  💡 제네릭이 무엇인지, 왜 사용하는지 설명해주세요

### 💡 final, finally, finalize 의 차이를 설명해주세요

### 💡 직렬화(Serialize)에 대해 설명해주세요

### 💡 SerialVersionUID 를 선언해야 하는 이유를 설명해주세요



