---
{"dg-publish":true,"permalink":"/publish/jpa/jpa/"}
---

## 페치 조인(Fetch Join)이란?

페치 조인은 JPQL에서 제공하는 성능 최적화 기능으로, 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능이다.

```sql
select m from Member m inner join fetch m.team
```

- SQL 조인 종류가 아님
- JPQL에서 **성능 최적화를 위해 제공**하는 기능
- **연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회**하는 기능
- join fetch 명령어로 사용할 수 있음
- `[LEFT [OUTER] | INNER] JOIN FETCH <조인 경로>`

## 페치 조인 vs 일반 조인

1. 페치 조인
	- 조회의 주체가 되는 엔티티와 페치 조인이 걸린 연관 엔티티 모두 함께 select하여 영속화
	- 페치 타입이 LAZY인 엔티티를 참조해도 이미 영속성 컨텍스트에 로드되어 있어 추가 쿼리 없이 **N + 1 문제를 해결**할 수 있다.
2. 일반 조인
	- 연관 엔티티에 조인을 걸어도 실제 select하는 엔티티는 JPQL에서 조회하는 주 엔티만 조회하여 영속화한다.
	- 데이터는 필요하지 않지만 연관 엔티티가 검색 조건에 필요한 경우에 주로 사용된다.


## 페치 조인의 특징과 한계

### 특징

- 연관된 엔티티들을 SQL 한 번으로 조회 -> 성능 최적화
- 엔티티에 직접 적용하는 글로벌 로딩 전략보다 우선함
	- @OneToMany(fetch = FetchType.LAZY) - 글로벌 로딩 전략
- 실무에서 글로벌 로딩 전략은 모두 지연 로딩
- 최적화가 필요한 곳은 페치 조인을 적용 -> N + 1이 걸리는 곳
- 컬렉션의 경우 `@BatchSize(size = 값)` 또는 글로벌 세팅(`properties`) 설정으로 리스트에 담긴 값을 한 번에 in 쿼리로 size 만큼 넘겨서 N + 1을 해결할 수 있다.
- 복잡한 페치 조인의 경우 @EntityGraph를 사용하여 더 유연하게 처리 가능

### 한계

- **페치 조인 대상에는 별칭을 줄 수 없다.**
	- 연관관계를 찾아간다는 것은 기본적으로 JPA의 설계 사상 자체가 Team에서 members로 갔을 때 members가 전부 나오는 것을 가정하고 설계가 되어있다.
	- 데이터 정합성 이슈가 발생한다.
	- 하이버네이트는 가능하지만 가급적 사용하지 않는 것이 좋음
	- 다중 페치 조인(A -> B, B -> C)으로 탐색을 할 경우에만 사용
- **둘 이상의 컬렉션은 페치 조인 할 수 없다.**
	- 1:N:N의 연관관계가 만들어지기 때문에 데이터 정합성 이슈(카테시안 곱) 발생
- **컬렉션을 페치 조인하면 페이징 API를 사용할 수 없다.**
	- 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징 가능
	- 하이버네이트는 경로 로그를 남기고 메모리에서 페이징 -> 매우 위험
	- 일대다를 패치 조인하면 데이터가 뻥튀기가 되고, 이 상황에서 첫 번째 페이지에 1개의 데이터만 나오게 페이징을 하면 JPA 입장에서는 "결과는 팀A 하나고 소속된 회원은 회원1 밖에 없어"라고 결과가 나온 것이 됨

## 정리

- 모든 것을 페치 조인으로 해결할 수는 없음
- 페치 조인은 객체 그래프를 유지할 때 사용하면 효과적임
- 여러 테이블을 조인해서 엔티티가 가진 모양이 아닌 전혀 다른 결과를 내야 하면, 페치 조인보다 일반 조인을 사용하고, 필요한 데이터들만 조회해서 DTO로 반환하는 것이 더 효과적임